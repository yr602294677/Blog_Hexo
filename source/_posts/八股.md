---
title: ## 八股
date: 2021-09-24 15:58:00
categories: "八股" 
tags: 八股
description: ## 面试问题准备


---





1. kafka

   * 为什么使用kafka
     * 缓冲和削峰：减少上游突发流量的冲击，将消息暂存在kafka中，让下游按照自己节奏慢慢处理，同时消息队列可以暂时堆积请求，即使消费者暂时挂掉，也不太影响业务正常运行
     * 解耦便于扩展：解耦重要流程，按照约定，传递消息即可
     * 异步通信：需要的时候再去处理发来的数据
   * kafka为什么快
     * kafka的消息是保存或缓存在磁盘上的
     * 写入数据快（写到硬盘中）
       * 顺序写入：（硬盘是机械结构，每次都会寻址并写入，寻址非常耗时）
         * 每个partition就是一个单独的文件，收到消息后将数据放到文件末尾
         * 消费者对每个topic都有一个单独的offset用于判断读取到哪个数据
         * offset由客户端保存
       * MMFile  Memory Mapped Files 内存映射文件
         * 充分利用了现代操作系统分页存储来利用内存提高I/O效率
         * 直接利用操作系统的Page来实现文件到物理内存的直接映射，完成映射之后你对物理内存的操作会被同步到硬盘上。
         * 但此操作不可靠，因为写到mmp的文件没有真正写到硬盘，只有程序主动flush时才会写到硬盘上
     * 读取数据快
       * 基于sendfile实现零拷贝
         * Kafka把所有的消息都存放在一个一个的文件中，当消费者需要数据的时候Kafka直接把文件发送给消费者，配合mmap作为文件读写方式，直接把它传给sendfile。减少了多次文件copy操作
         * 传统方式需要 数据-》硬盘-》内核缓冲区-》用户空间缓冲区-》内核空间socket缓冲区-》nic缓冲区-》网络发送到客户端
       * 批量压缩
         * Kafka允许使用递归的消息集合，批量的消息可以通过压缩的形式传输并且在日志中也可以保持压缩格式，直到被消费者解压缩
     * 总结
       * 写数据时直接在单个partion文件的末尾添加，速度最快
       * 传递消息时将所有消息变成一个批量的文件，并进行合理压缩以减少网络io损耗
       * 读取消息时配合sendfile直接传递文件，减少copy次数

2. hashmap

   *   引入了红黑二叉树设计，当冲突的链表长度大于 8 时，会将链表转化成红黑二叉树结构，提高查询效率。 

   * hashmap为啥是线程不安全的

     * hashmap的put方法用的是++i，由于"++i"操作并不是单单一行代码处理，它包含了“读取、添加、保存”的过程。而在多线程处理的情况下，线程A在执行“+1”的操作的时候如果没有保存而被切换走进行线程B的数据处理，最终就没有执行“+1”而出现数据不一致问题，因为我们拿到的数据不是保存操作后的，它就不具备原子性。

     * 可能出现数据覆盖的情况

       ```java
       // 如果没有hash碰撞则直接插入元素，若AB两个线程同时插入不同数据且两个数据hash值一样，此时同时进入以下代码
       //先执行的可能被后执行的覆盖
       if ((p = tab[i = (n - 1) & hash]) == null){
           tab[i] = newNode(hash, key, value, null);
        }
       ......
       ++this.modCount; //注意++this.modCount组合
       if (++this.size > this.threshold) {
             this.resize();
       }
       ```

     * 示例

       ```java
       public class test {
           public static void main(String[] args) {
               HashMapThread thread0 = new HashMapThread();
               HashMapThread thread1 = new HashMapThread();
               HashMapThread thread2 = new HashMapThread();
               thread0.start();
               thread1.start();
               thread2.start();
           }
       }
       
       class HashMapThread extends Thread {
           private static AtomicInteger ai = new AtomicInteger();
           private static Map<Integer, Integer> map = new HashMap<>();
       
           @Override
           public void run() {
               while (ai.get() < 10) {
                   map.put(ai.get(), ai.get());
                   ai.incrementAndGet();
                   System.out.println( map);
               }
           }
       }
       ```

       ```java
       {0=0, 2=2}
       {0=0, 2=2}
       {0=0, 2=2}
       {0=0, 4=4, 2=2, 3=3}
       {0=0, 2=2, 3=3}
       {0=0, 4=4, 5=5, 2=2, 6=6, 3=3}
       {0=0, 4=4, 5=5, 2=2, 3=3}
       {0=0, 4=4, 5=5, 2=2, 6=6, 3=3, 7=7, 8=8}
       {0=0, 4=4, 5=5, 2=2, 6=6, 3=3, 7=7}
       {8=8, 9=9, 2=2, 3=3, 5=5, 4=4, 6=6, 7=7}
       
       ```

   * concurrenthashmap是怎么实现线程安全的？

     * hashtable是直接在get和put上加synchronized关键字，在高并发情况下影响效率
     
     *  共享变量的存储和读取全部通过volatile或CAS的方式来保证并发安全 ，同时put时 只锁定当前链表或红黑二叉树的首节点，只要节点 hash 不冲突，就不会产生并发 
     
       *  **cas **：compare and swap 
     
         *  CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 
     
           ```java
           if(valueOf(V)==A){
           	A==B;
           }
           ```
     
           
     
         * 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。
     
         * CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” 
     
     * （1.7） 分段部分数据锁定 ，一个concurrenthashmap由多个segment组成，每个segment'有单独的锁，通过Hash函数将即将要put 的元素均匀的放到所需要的Segment 段中，然后调用Segment的put （ **加锁**）方法进行添加数据 
     
   * concurrenthashmap的key和value不允许为null
     
     * 无法确定是value存的就是null还是说key不存在，可能引起歧义，但hashmap非并发编程中可以进一步调用containsKey来判断

* 平衡二叉树

3. get、post区别
   * get是幂等的，一般用于获取资源；post是非幂等的，一般用于创建或更新资源
   * get不安全，因为数据放在url中，post则放在requestbody中
   * post在后退或者刷新时会提示重新提交数据，get无反应
   * get提交数据最长为2048字节（浏览器或服务器添加的此限制）
   * get是head和data一起发，服务器返回200；post是head发了，服务器返回100，再发data